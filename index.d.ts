// Type definitions for webmidi.js
// Project: https://github.com/djipco/webmidi
// Definitions by: S.Albert <https://github.com/s-albert>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

// @types/webmidi causes a name clash when importing webmidi of webmidi.js.
// The compiler would not find webmidi.js, because it uses @types/webmidi instead.
// Therefore I fixed this with simply including the @types/webmidi at the beginning of this file.
// The d.ts was generated by jsdoc2dts and manually adapted (e.g. Array > Array<any>, protected functions removed)

// Type definitions for Web MIDI API 2.0
// Project: http://www.w3.org/TR/webmidi/
// Definitions by: six a <https://github.com/lostfictions>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

interface Navigator {
  /**
   * When invoked, returns a Promise object representing a request for access to MIDI
   * devices on the user's system.
   */
  requestMIDIAccess(options?: WebMidi.MIDIOptions): Promise<WebMidi.MIDIAccess>;
}

declare namespace WebMidi {
  interface MIDIOptions {
    /**
     * This member informs the system whether the ability to send and receive system
     * exclusive messages is requested or allowed on a given MIDIAccess object.
     */
    sysex: boolean;
  }

  /**
   * This is a maplike interface whose value is a MIDIInput instance and key is its
   * ID.
   */
  type MIDIInputMap = Map<string, MIDIInput>;

  /**
   * This is a maplike interface whose value is a MIDIOutput instance and key is its
   * ID.
   */
  type MIDIOutputMap = Map<string, MIDIOutput>;

  interface MIDIAccess extends EventTarget {
    /**
     * The MIDI input ports available to the system.
     */
    inputs: MIDIInputMap;

    /**
     * The MIDI output ports available to the system.
     */
    outputs: MIDIOutputMap;

    /**
     * The handler called when a new port is connected or an existing port changes the
     * state attribute.
     */
    onstatechange(e: MIDIConnectionEvent): void;

    /**
     * This attribute informs the user whether system exclusive support is enabled on
     * this MIDIAccess.
     */
    sysexEnabled: boolean;
  }

  type MIDIPortType = 'input' | 'output';

  type MIDIPortDeviceState = 'disconnected' | 'connected';

  type MIDIPortConnectionState = 'open' | 'closed' | 'pending';

  interface MIDIPort extends EventTarget {
    /**
     * A unique ID of the port. This can be used by developers to remember ports the
     * user has chosen for their application.
     */
    id: string;

    /**
     * The manufacturer of the port.
     */
    manufacturer?: string;

    /**
     * The system name of the port.
     */
    name?: string;

    /**
     * A descriptor property to distinguish whether the port is an input or an output
     * port.
     */
    type: MIDIPortType;

    /**
     * The version of the port.
     */
    version?: string;

    /**
     * The state of the device.
     */
    state: MIDIPortDeviceState;

    /**
     * The state of the connection to the device.
     */
    connection: MIDIPortConnectionState;

    /**
     * The handler called when an existing port changes its state or connection
     * attributes.
     */
    onstatechange(e: MIDIConnectionEvent): void;

    /**
     * Makes the MIDI device corresponding to the MIDIPort explicitly available. Note
     * that this call is NOT required in order to use the MIDIPort - calling send() on
     * a MIDIOutput or attaching a MIDIMessageEvent handler on a MIDIInputPort will
     * cause an implicit open().
     *
     * When invoked, this method returns a Promise object representing a request for
     * access to the given MIDI port on the user's system.
     */
    open(): Promise<MIDIPort>;

    /**
     * Makes the MIDI device corresponding to the MIDIPort
     * explicitly unavailable (subsequently changing the state from "open" to
     * "connected"). Note that successful invocation of this method will result in MIDI
     * messages no longer being delivered to MIDIMessageEvent handlers on a
     * MIDIInputPort (although setting a new handler will cause an implicit open()).
     *
     * When invoked, this method returns a Promise object representing a request for
     * access to the given MIDI port on the user's system. When the port has been
     * closed (and therefore, in exclusive access systems, the port is available to
     * other applications), the vended Promise is resolved. If the port is
     * disconnected, the Promise is rejected.
     */
    close(): Promise<MIDIPort>;
  }

  interface MIDIInput extends MIDIPort {
    onmidimessage(e: MIDIMessageEvent): void;
  }

  interface MIDIOutput extends MIDIPort {
    /**
     * Enqueues the message to be sent to the corresponding MIDI port.
     * @param data The data to be enqueued, with each sequence entry representing a single byte of data.
     * @param timestamp The time at which to begin sending the data to the port. If timestamp is set
     * to zero (or another time in the past), the data is to be sent as soon as
     * possible.
     */
    send(data: number[] | Uint8Array, timestamp?: number): void;

    /**
     * Clears any pending send data that has not yet been sent from the MIDIOutput 's
     * queue. The implementation will need to ensure the MIDI stream is left in a good
     * state, so if the output port is in the middle of a sysex message, a sysex
     * termination byte (0xf7) should be sent.
     */
    clear(): void;
  }

  interface MIDIMessageEvent extends Event {
    /**
     * A timestamp specifying when the event occurred.
     */
    receivedTime: number;

    /**
     * A Uint8Array containing the MIDI data bytes of a single MIDI message.
     */
    data: Uint8Array;
  }

  interface MIDIMessageEventInit extends EventInit {
    /**
     * A timestamp specifying when the event occurred.
     */
    receivedTime: number;

    /**
     * A Uint8Array containing the MIDI data bytes of a single MIDI message.
     */
    data: Uint8Array;
  }

  interface MIDIConnectionEvent extends Event {
    /**
     * The port that has been connected or disconnected.
     */
    port: MIDIPort;
  }

  interface MIDIConnectionEventInit extends EventInit {
    /**
     * The port that has been connected or disconnected.
     */
    port: MIDIPort;
  }
}

/**
 * The `WebMidi` object makes it easier to work with the Web MIDI API. Basically, it simplifies
 * two things: sending outgoing MIDI messages and reacting to incoming MIDI messages.
 *
 * Sending MIDI messages is done via an `Output` object. All available outputs can be accessed in
 * the `WebMidi.outputs` array. There is one `Output` object for each output port available on
 * your system. Similarly, reacting to MIDI messages as they are coming in is simply a matter of
 * adding a listener to an `Input` object. Similarly, all inputs can be found in the
 * `WebMidi.inputs` array.
 *
 * Please note that a single hardware device might create more than one input and/or output ports.
 *
 * #### Sending messages
 *
 * To send MIDI messages, you simply need to call the desired method (`playNote()`,
 * `sendPitchBend()`, `stopNote()`, etc.) from an `Output` object and pass in the appropriate
 * parameters. All the native MIDI communication will be handled for you. The only additional
 * thing that needs to be done is to first enable `WebMidi`. Here is an example:
 *
 *      WebMidi.enable(function(err) {
 *        if (err) console.log("An error occurred", err);
 *        WebMidi.outputs[0].playNote("C3");
 *      });
 *
 * The code above, calls the `WebMidi.enable()` method. Upon success, this method executes the
 * callback function specified as a parameter. In this case, the callback calls the `playnote()`
 * function to play a 3rd octave C on the first available output port.
 *
 * #### Receiving messages
 *
 * Receiving messages is just as easy. You simply have to set a callback function to be triggered
 * when a specific MIDI message is received. For example, here's how to listen for pitch bend
 * events on the first input port:
 *
 *      WebMidi.enable(function(err) {
 *        if (err) console.log("An error occurred", err);
 *
 *        WebMidi.inputs[0].addListener('pitchbend', "all", function(e) {
 *          console.log("Pitch value: " + e.value);
 *        });
 *
 *      });
 *
 * As you can see, this library is much easier to use than the native Web MIDI API. No need to
 * manually craft or decode binary MIDI messages anymore!
 *
 * @class WebMidi
 * @static
 *
 * @throws Error WebMidi is a singleton, it cannot be instantiated directly.
 *
 * @todo  Implement port statechange events.
 * @todo  Test with the Node.js version of Jazz Plugin. Initial tests are promising.
 * @todo  Complete tests
 * @todo  Refine "options" param of addListener. Allow listening for specific controller change.
 * @todo  Add once() function.
 * @todo  Yuidoc does not allow multiple exceptions (@throws) for a single method ?!
 * @todo  Should the sendsysex method allow Uint8Array param ?
 * @todo  allow adjustment of the start point for octaves (-2, -1, 0, etc.). See:
 *        https://en.wikipedia.org/wiki/Scientific_pitch_notation
 * @todo  Add explicit support for universal system exclusive messages, real time (0x7F and non-real time)
 * @todo  Implement the show control protocol subset.
 * @todo  Add methods for channel mode messages
 * @todo  Allow send() to accept Uint8Array output.send(new Uint8Array([0x90, 0x45, 0x7f]));
 *
 */

declare class WebMidi {
  /**
   * The `WebMidi` object makes it easier to work with the Web MIDI API. Basically, it simplifies
   * two things: sending outgoing MIDI messages and reacting to incoming MIDI messages.
   *
   * Sending MIDI messages is done via an `Output` object. All available outputs can be accessed in
   * the `WebMidi.outputs` array. There is one `Output` object for each output port available on
   * your system. Similarly, reacting to MIDI messages as they are coming in is simply a matter of
   * adding a listener to an `Input` object. Similarly, all inputs can be found in the
   * `WebMidi.inputs` array.
   *
   * Please note that a single hardware device might create more than one input and/or output ports.
   *
   * #### Sending messages
   *
   * To send MIDI messages, you simply need to call the desired method (`playNote()`,
   * `sendPitchBend()`, `stopNote()`, etc.) from an `Output` object and pass in the appropriate
   * parameters. All the native MIDI communication will be handled for you. The only additional
   * thing that needs to be done is to first enable `WebMidi`. Here is an example:
   *
   *      WebMidi.enable(function(err) {
   *        if (err) console.log("An error occurred", err);
   *        WebMidi.outputs[0].playNote("C3");
   *      });
   *
   * The code above, calls the `WebMidi.enable()` method. Upon success, this method executes the
   * callback function specified as a parameter. In this case, the callback calls the `playnote()`
   * function to play a 3rd octave C on the first available output port.
   *
   * #### Receiving messages
   *
   * Receiving messages is just as easy. You simply have to set a callback function to be triggered
   * when a specific MIDI message is received. For example, here's how to listen for pitch bend
   * events on the first input port:
   *
   *      WebMidi.enable(function(err) {
   *        if (err) console.log("An error occurred", err);
   *
   *        WebMidi.inputs[0].addListener('pitchbend', "all", function(e) {
   *          console.log("Pitch value: " + e.value);
   *        });
   *
   *      });
   *
   * As you can see, this library is much easier to use than the native Web MIDI API. No need to
   * manually craft or decode binary MIDI messages anymore!
   *
   * @class WebMidi
   * @static
   *
   * @throws Error WebMidi is a singleton, it cannot be instantiated directly.
   *
   * @todo  Implement port statechange events.
   * @todo  Test with the Node.js version of Jazz Plugin. Initial tests are promising.
   * @todo  Complete tests
   * @todo  Refine "options" param of addListener. Allow listening for specific controller change.
   * @todo  Add once() function.
   * @todo  Yuidoc does not allow multiple exceptions (@throws) for a single method ?!
   * @todo  Should the sendsysex method allow Uint8Array param ?
   * @todo  allow adjustment of the start point for octaves (-2, -1, 0, etc.). See:
   *        https://en.wikipedia.org/wiki/Scientific_pitch_notation
   * @todo  Add explicit support for universal system exclusive messages, real time (0x7F and non-real time)
   * @todo  Implement the show control protocol subset.
   * @todo  Add methods for channel mode messages
   * @todo  Allow send() to accept Uint8Array output.send(new Uint8Array([0x90, 0x45, 0x7f]));
   *
   */
  constructor();
}

interface IMessages {
  value: {};
  writable: boolean;
  enumerable: boolean;
  configurable: boolean;
}

export interface MIDI_SYSTEM_MESSAGES {
  MIDI_SYSTEM_MESSAGES: IMessages;
}

/**
 * [read-only] List of valid MIDI system messages and matching hexadecimal values.
 *
 * Note: values 249 and 253 are actually dispatched by the Web MIDI API but I do not know what
 * they are used for. They are not part of the online
 * [MIDI 1.0 spec](http://www.midi.org/techspecs/midimessages.php).
 *
 * @property MIDI_SYSTEM_MESSAGES
 * @type Object
 * @static
 *
 * @since 2.0.0
 */
export var MIDI_SYSTEM_MESSAGES: IMessages;

export interface MIDI_CHANNEL_MESSAGES {
  MIDI_CHANNEL_MESSAGES: IMessages;
}

/**
 * [read-only] List of valid MIDI channel messages and matching hexadecimal values.
 *
 * @property MIDI_CHANNEL_MESSAGES
 * @type Object
 * @static
 *
 * @since 2.0.0
 */
export var MIDI_CHANNEL_MESSAGES: IMessages;

export interface MIDI_REGISTERED_PARAMETER {
  MIDI_REGISTERED_PARAMETER: IMessages;
}

/**
 * [read-only] List of valid MIDI registered parameters and their matching pair of hexadecimal
 * values. MIDI registered parameters extend the original list of control change messages.
 * Currently, there are only a limited number of them.
 *
 * @property MIDI_REGISTERED_PARAMETER
 * @type Object
 * @static
 *
 * @since 2.0.0
 */
export var MIDI_REGISTERED_PARAMETER: IMessages;

export interface MIDI_CONTROL_CHANGE_MESSAGES {
  MIDI_CONTROL_CHANGE_MESSAGES: IMessages;
}

/**
 * [read-only] List of MIDI control change messages
 *
 * valid MIDI registered parameterS and their matching pair of hexadecimal
 * values. MIDI registered parameters extend the original list of control change messages.
 * Currently, there are only a limited number of them.
 *
 * @property MIDI_CONTROL_CHANGE_MESSAGES
 * @type Object
 * @static
 *
 * @since 2.0.0
 */
export var MIDI_CONTROL_CHANGE_MESSAGES: IMessages;

export interface MIDI_CHANNEL_MODE_MESSAGES {
  MIDI_CHANNEL_MODE_MESSAGES: IMessages;
}

/**
 * [read-only] List of MIDI channel mode messages as defined in the official MIDI
 * specification.
 *
 * @property MIDI_CHANNEL_MODE_MESSAGES
 * @type Object
 * @static
 *
 * @since 2.0.0
 */
export var MIDI_CHANNEL_MODE_MESSAGES: IMessages;

/**
 * [read-only] Indicates whether the environment supports the Web MIDI API or not.
 *
 * Note: in environments that do not offer built-in MIDI support, this will report true if the
 * `navigator.requestMIDIAccess` function is available. For example, if you have installed
 * WebMIDIAPIShim but no plugin, this property will be true even though actual support might
 * not be there.
 *
 * @property supported
 * @type Boolean
 * @static
 */
export var supported: Boolean;

/**
 * [read-only] Indicates whether the interface to the host's MIDI subsystem is currently
 * enabled.
 *
 * @property enabled
 * @type Boolean
 * @static
 */
export var enabled: Boolean;

/**
 * [read-only] An array of all currently available MIDI input ports.
 *
 * @property inputs
 * @type {Array}
 * @static
 */
export var inputs: Array<WebMidi.MIDIInput>;

/**
 * [read-only] An array of all currently available MIDI output ports.
 *
 * @property outputs
 * @type {Array}
 * @static
 */
export var outputs: Array<WebMidi.MIDIOutput>;

/**
 * [read-only] Indicates whether the interface to the host's MIDI subsystem is currently
 * active.
 *
 * @property sysexEnabled
 * @type Boolean
 * @static
 */
export var sysexEnabled: Boolean;

/**
 * [read-only] Current MIDI performance time in milliseconds. This can be used to queue events
 * in the future.
 *
 * @property time
 * @type number
 * @static
 */
export var time: number;

/**
 * Checks if the Web MIDI API is available and then tries to connect to the host's MIDI subsystem.
 * This is an asynchronous operation. When it's done, the specified handler callback will be
 * executed. If an error occurred, the callback function will receive an `Error` object as its
 * sole parameter.
 *
 * To enable the use of system exclusive messages, the `sysex` parameter should be set to true.
 * However, under some environments (e.g. Jazz-Plugin), the sysex parameter is ignored and sysex
 * is always enabled.
 *
 * @method enable
 * @static
 *
 * @param [callback] {Function} A function to execute upon success. This function will receive an
 * `Error` object upon failure to enable the Web MIDI API.
 * @param [sysex=false] {Boolean} Whether to enable MIDI system exclusive messages or not.
 *
 * @throws Error The Web MIDI API is not supported by your browser.
 * @throws Error Jazz-Plugin must be installed to use WebMIDIAPIShim.
 */
declare function enable(callback?: ((error?: object) => any), sysex?: Boolean): void;

/**
 * Completely disables `WebMidi` by unlinking the MIDI subsystem's interface and destroying all
 * `Input` and `Output` objects that may be available. This also means that any listener that may
 * have been defined on `Input` or `Output` objects will be destroyed.
 *
 * @method disable
 * @static
 *
 * @since 2.0.0
 */
declare function disable(): void;

/**
 * Adds an event listener on the `WebMidi` object that will trigger a function callback when the
 * specified event happens.
 *
 * WebMidi must be enabled before adding event listeners.
 *
 * Currently, only one event is being dispatched by the `WebMidi` object:
 *
 *    * {{#crossLink "WebMidi/statechange:event"}}statechange{{/crossLink}}
 *
 * @method addListener
 * @static
 * @chainable
 *
 * @param type {String} The type of the event.
 *
 * @param listener {Function} A callback function to execute when the specified event is detected.
 * This function will receive an event parameter object. For details on this object's properties,
 * check out the documentation for the various events (links above).
 *
 * @throws {Error} WebMidi must be enabled before adding event listeners.
 * @throws {TypeError} The specified event type is not supported.
 * @throws {TypeError} The 'listener' parameter must be a function.
 *
 * @return {WebMidi} Returns the `WebMidi` object so methods can be chained.
 */
declare function addListener(type: string, listener: (() => any)): WebMidi;

/**
 * Checks if the specified event type is already defined to trigger the specified listener
 * function.
 *
 * @method hasListener
 * @static
 *
 * @param {String} type The type of the event.
 * @param {Function} listener The callback function to check for.
 *
 * @throws {Error} WebMidi must be enabled before checking event listeners.
 * @throws {TypeError} The 'listener' parameter must be a function.
 * @throws {TypeError} The specified event type is not supported.
 *
 * @return {Boolean} Boolean value indicating whether or not a callback is already defined for
 * this event type.
 */
declare function hasListener(type: string, listener: (() => any)): Boolean;

/**
 * Removes the specified listener(s). If the `listener` parameter is left undefined, all listeners
 * for the specified `type` will be removed. If both the `listener` and the `type` parameters are
 * omitted, all listeners attached to the `WebMidi` object will be removed.
 *
 * @method removeListener
 * @static
 * @chainable
 *
 * @param {String} [type] The type of the event.
 * @param {Function} [listener] The callback function to check for.
 *
 * @throws {Error} WebMidi must be enabled before removing event listeners.
 * @throws {TypeError} The 'listener' parameter must be a function.
 * @throws {TypeError} The specified event type is not supported.
 *
 * @return {WebMidi} The `WebMidi` object for easy method chaining.
 */
declare function removeListener(type?: string, listener?: (() => any)): WebMidi;

/**
 * Converts an input value (which should be an integer, an array of integers, `"all"` or
 * `undefined`) to an array of valid MIDI channel numbers. Passing `"all"` or `undefined` to this
 * function results in all channels being returned (1-16).
 *
 * Elements in the array that cannot successfully be parsed to integers between 1 and 16 (using
 * `parseInt()`) are silently removed.
 *
 * @method toMIDIChannels
 * @param [channel] {uint|Array}
 * @returns {Array}
 * @protected
 */
export function toMIDIChannels(channel?: number | Array<number>): Array<number>;

/**
 *
 * Returns an `Input` object representing the input port with the specified id.
 *
 * Please note that the IDs change from one host to another. For example, Chrome does not use the
 * same kind of IDs as the Jazz-Plugin.
 *
 * @method getInputById
 * @static
 *
 * @param id {String} The id of the port. IDs can be viewed by looking at the `WebMidi.inputs`
 * array.
 *
 * @returns {Input|false} A MIDIInput port matching the specified id. If no matching port
 * can be found, the method returns `false`.
 *
 * @since 2.0.0
 */
declare function getInputById(id: string): Input | false;

/**
 *
 * Returns an `Output` object representing the output port matching the specified id.
 *
 * Please note that the IDs change from one host to another. For example, Chrome does not use the
 * same kind of IDs as the Jazz-Plugin.
 *
 * @method getOutputById
 * @static
 *
 * @param id {String} The id of the port. Ids can be viewed by looking at the `WebMidi.outputs`
 * array.
 *
 * @returns {Output|false} A MIDIOutput port matching the specified id. If no matching
 * port can be found, the method returns `false`.
 *
 * @since 2.0.0
 */
declare function getOutputById(id: string): Output | false;

/**
 * Returns the first MIDI `Input` whose name *contains* the specified string.
 *
 * Please note that the port names change from one host to another. For example, Chrome does
 * not report port names in the same way as the Jazz-Plugin does.
 *
 * @method getInputByName
 * @static
 *
 * @param name {String} The name of a MIDI input port such as those visible in the
 * `WebMidi.inputs` array.
 *
 * @returns {Input|false} The `Input` that was found or `false` if no input matched the specified
 * name.
 *
 * @throws Error WebMidi is not enabled.
 * @throws TypeError The name must be a string.
 *
 * @since 2.0.0
 */
declare function getInputByName(name: string): Input | false;

/**
 * Returns the octave number for the specified MIDI note number. The returned value will be
 * between -2 and 8. If the note number passed to `getOctave()` is invalid, `undefined` will be
 * returned.
 *
 * @method getOctave
 * @static
 *
 * @param number {Number} An integer representing a valid MIDI note number (between 0 and 127).
 *
 * @returns {Number} The octave as an integer between -2 and 8 (or `undefined`).
 *
 * @since 2.0.0-rc.6
 */
declare function getOctave(number: number): number;

/**
 * Returns the first MIDI `Output` that matches the specified name.
 *
 * Please note that the port names change from one host to another. For example, Chrome does
 * not report port names in the same way as the Jazz-Plugin does.
 *
 * @method getOutputByName
 * @static
 *
 * @param name {String} The name of a MIDI output port such as those visible in the
 * `WebMidi.outputs` array.
 *
 * @returns {Output|false} The `Output` that was found or `false` if no output matched the
 * specified name.
 *
 * @throws Error WebMidi is not enabled.
 *
 * @since 2.0.0
 */
declare function getOutputByName(name: string): Output | false;

/**
 * Returns a valid MIDI note number given the specified input. The input can be a note name (C3,
 * F#4, D-2, G8, etc.) or an int between 0 and 127.
 *
 * @method guessNoteNumber
 * @static
 *
 * @param input {Number|string} A string to extract the note number from. An integer can also be
 * used, in which case it will simply be returned (if between 0 and 127).
 * @throws {Error} Invalid note number.
 * @returns {Number} A valid MIDI note number (0-127).
 */
declare function guessNoteNumber(input: number | string): number;

/**
 * Returns a MIDI note number matching the note name passed in the form of a string parameter. The
 * note name must include the octave number which should be between -2 and 8. The name can also
 * optionally include a sharp "#" or double sharp "##" symbol and a flat "b" or double flat "bb"
 * symbol: C5, G4, D#-1, F0, Gb7, Eb-1, Abb4, B##6, etc.
 *
 * The lowest note is C-2 (MIDI note number 0) and the highest note is G8 (MIDI note number 127).
 *
 * @method noteNameToNumber
 * @static
 *
 * @param name {String} The name of the note in the form of a letter, followed by an optional "#",
 * "##", "b" or "bb" followed by the octave number (between -2 and 8).
 *
 * @throws {RangeError} Invalid note name.
 * @throws {RangeError} Invalid note name or note outside valid range.
 * @return {Number} The MIDI note number (between 0 and 127)
 */
declare function noteNameToNumber(name: string): number;

/**
 * The `Input` object represents a MIDI input port on the host system. This object is created by
 * the MIDI subsystem and cannot be instantiated directly.
 *
 * You will find all available `Input` objects in the `WebMidi.inputs` array.
 *
 * @class Input
 * @param {MIDIInput} midiInput `MIDIInput` object
 */
export class Input {
  /**
   * The `Input` object represents a MIDI input port on the host system. This object is created by
   * the MIDI subsystem and cannot be instantiated directly.
   *
   * You will find all available `Input` objects in the `WebMidi.inputs` array.
   *
   * @class Input
   * @param {MIDIInput} midiInput `MIDIInput` object
   */
  constructor(midiInput: WebMidi.MIDIInput);
}

/**
 * [read-only] Status of the MIDI port's connection (`pending`, `open` or `closed`)
 *
 * @property connection
 * @type String
 */
export var connection: string;

/**
 * [read-only] ID string of the MIDI port. The ID is host-specific. Do not expect the same ID
 * on different platforms. For example, Google Chrome and the Jazz-Plugin report completely
 * different IDs for the same port.
 *
 * @property id
 * @type String
 */
export var id: string;

/**
 * [read-only] Name of the manufacturer of the device that makes this port available.
 *
 * @property manufacturer
 * @type String
 */
export var manufacturer: string;

/**
 * [read-only] Name of the MIDI port
 *
 * @property name
 * @type String
 */
export var name: string;

/**
 * [read-only] State of the MIDI port (`connected` or `disconnected`)
 *
 * @property state
 * @type String
 */
export var state: string;

/**
 * [read-only] Type of the MIDI port (`input`)
 *
 * @property type
 * @type String
 */
export var type: string;

/**
 * This is an alias to the {{#crossLink "Input/addListener"}}Input.addListener(){{/crossLink}}
 * function.
 *
 * @method on
 * @since 2.0.0
 */
export function on(): void;

/**
 * Returns the name of a control change message matching the specified number. If no match is
 * found, the function returns `undefined`.
 *
 * @method getCcNameByNumber
 *
 * @param number {Number} The number of the control change message.
 * @returns {String|undefined} The matching control change name or `undefined`.
 *
 * @throws RangeError The control change number must be between 0 and 119.
 *
 * @since 2.0.0
 */
export function getCcNameByNumber(number: number): string | undefined;

/**
 * Returns the channel mode name matching the specified number. If no match is found, the function
 * returns `undefined`.
 *
 * @method getChannelModeByNumber
 *
 * @param number {Number} The number of the channel mode message.
 * @returns {String|undefined} The matching channel mode message's name or `undefined`;
 *
 * @throws RangeError The channel mode number must be between 120 and 127.
 *
 * @since 2.0.0
 */
export function getChannelModeByNumber(number: number): string | undefined;

/**
 * The `Output` object represents a MIDI output port on the host system. This object is created by
 * the MIDI subsystem and cannot be instantiated directly.
 *
 * You will find all available `Output` objects in the `WebMidi.outputs` array.
 *
 * @class Output
 * @param {MIDIOutput} midiOutput Actual `MIDIOutput` object as defined by the MIDI subsystem
 */
export class Output {
  /**
   * The `Output` object represents a MIDI output port on the host system. This object is created by
   * the MIDI subsystem and cannot be instantiated directly.
   *
   * You will find all available `Output` objects in the `WebMidi.outputs` array.
   *
   * @class Output
   * @param {MIDIOutput} midiOutput Actual `MIDIOutput` object as defined by the MIDI subsystem
   */
  constructor(midiOutput: WebMidi.MIDIOutput);
}

/**
 * Sends a MIDI message on the MIDI output port, at the scheduled timestamp.
 *
 * Unless, you are familiar with the details of the MIDI message format, you should not use this
 * method directly. Instead, use one of the simpler helper methods: `playNote()`, `stopNote()`,
 * `sendControlChange()`, `sendSystemMessage()`, etc.
 *
 * Details on the format of MIDI messages are available in the
 * <a href="http://www.midi.org/techspecs/midimessages.php">summary of MIDI messages</a> of the
 * MIDI Manufacturers Association.
 *
 * @method send
 * @chainable
 *
 * @param status {Number} The MIDI status byte of the message (128-255).
 *
 * @param [data=[]] {Array} An array of uints for the message. The number of data bytes varies
 * depending on the status byte. It is perfectly legal to send no data for some message types (use
 * undefined or an empty array in this case). Each byte must be between 0 and 255.
 *
 * @param [timestamp=0] {number} The timestamp at which to send the message. You can
 * use `WebMidi.time` to retrieve the current timestamp. To send immediately, leave blank or use
 * 0.
 *
 * @throws {RangeError} The status byte must be an integer between 128 (0x80) and 255 (0xFF).
 * @throws {RangeError} Data bytes must be integers between 0 (0x00) and 255 (0x7F).
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function send(status: number, data?: Array<number>, timestamp?: number): Output;

/**
 * Sends a MIDI *system exclusive* (sysex) message. The generated message will automatically be
 * prepended with the *sysex* byte (0xF0) and terminated with the *end of sysex* byte (0xF7).
 *
 * To use the `sendSysex()` method, system exclusive message support must have been enabled. To
 * do so, you must pass `true` as the second parameter to `WebMidi.enable()`:
 *
 *     WebMidi.enable(function (err) {
 *         if (err) {
 *             console.warn(err);
 *         } else {
 *             console.log("Sysex is enabled!");
 *         }
 *     }, true);
 *
 * Note that, depending on browser, version and platform, it may be necessary to serve the page
 * over HTTPS to enable sysex support.
 *
 * #### Examples
 *
 * If you want to send a sysex message to a Korg device connected to the first output, you would
 * use the following code:
 *
 *     WebMidi.outputs[0].sendSysex(0x42, [1, 2, 3, 4, 5]);
 *
 * The above code sends the byte values 1, 2, 3, 4 and 5 to Korg (ID 0x42) devices. Some
 * manufacturers are identified using 3 bytes. In this case, you would use a 3-position array as
 * the first parameter. For example, to send the same sysex message to a *Native Instruments*
 * device:
 *
 *     WebMidi.outputs[0].sendSysex([0x00, 0x21, 0x09], [1, 2, 3, 4, 5]);
 *
 * There is no limit for the length of the data array. However, it is generally suggested to keep
 * system exclusive messages to 64Kb or less.
 *
 * @method sendSysex
 * @chainable
 *
 * @param manufacturer {Number|Array} An unsigned integer or an array of three unsigned integers
 * between 0 and 127 that identify the targeted manufacturer. The *MIDI Manufacturers Association*
 * maintains a full list of
 * [Manufacturer ID Numbers](https://www.midi.org/specifications/item/manufacturer-id-numbers).
 *
 * @param [data=[]] {Array} An array of uints between 0 and 127. This is the data you wish to
 * transfer.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throw Sysex message support must first be activated.
 * @throw The data bytes of a sysex message must be integers between 0 (0x00) and 127 (0x7F).
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendSysex(
  manufacturer: number | Array<number>,
  data?: Array<number>,
  options?: { time?: number | string }
): Output;

/**
 * Sends a *MIDI Timecode Quarter Frame* message. Please note that no processing is being done on
 * the data. It is up to the developer to format the data according to the
 * [MIDI Timecode](https://en.wikipedia.org/wiki/MIDI_timecode) format.
 *
 * @method sendTimecodeQuarterFrame
 * @chainable
 *
 * @param value {Number} The quarter frame message content (integer between 0 and 127).
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendTimecodeQuarterFrame(value: number, options?: { time?: number | string }): Output;

/**
 * Sends a *Song Position* MIDI message. The value is expressed in MIDI beats (between 0 and
 * 16383) which are 16th note. Position 0 is always the start of the song.
 *
 * @method sendSongPosition
 * @chainable
 *
 * @param [value=0] {Number} The MIDI beat to cue to (int between 0 and 16383).
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendSongPosition(value?: number, options?: { time?: number | string }): Output;

/**
 * Sends a *Song Select* MIDI message. Beware that some devices will display position 0 as
 * position 1 for user-friendlyness.
 *
 * @method sendSongSelect
 * @chainable
 *
 * @param value {Number} The number of the song to select (integer between 0 and 127).
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throw The song number must be between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendSongSelect(value: number, options?: { time?: number | string }): Output;

/**
 * Sends a *MIDI tuning request* real-time message.
 *
 * Note: there is currently a bug in Chrome's MIDI implementation. If you try to use this
 * function, Chrome will actually throw a "Message is incomplete" error. The bug is
 * [scheduled to be fixed](https://bugs.chromium.org/p/chromium/issues/detail?id=610116).
 *
 * @method sendTuningRequest
 * @chainable
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendTuningRequest(options?: { time?: number | string }): Output;

/**
 * Sends a *MIDI Clock* real-time message. According to the standard, there are 24 MIDI Clocks
 * for every quarter note.
 *
 * @method sendClock
 * @chainable
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendClock(options?: { time?: number | string }): Output;

/**
 * Sends a *Start* real-time message. A MIDI Start message starts the playback of the current
 * song at beat 0. To start playback elsewhere in the song, use the `sendContinue()` function.
 *
 * @method sendStart
 * @chainable
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendStart(options?: { time?: number | string }): Output;

/**
 * Sends a *Continue* real-time message. This resumes song playback where it was previously
 * stopped or where it was last cued with a song position message. To start playback from the
 * start, use the `sendStart()` function.
 *
 * @method sendContinue
 * @chainable
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {WebMidi} Returns the `WebMidi` object so methods can be chained.
 */
export function sendContinue(options?: { time?: number | string }): WebMidi;

/**
 * Sends a *Stop* real-time message. This tells the device connected to this port to stop playback
 * immediately (or at the scheduled time).
 *
 * @method sendStop
 * @chainable
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendStop(options?: { time?: number | string }): Output;

/**
 * Sends an *Active Sensing* real-time message. This tells the device connected to this port that
 * the connection is still good. Active sensing messages should be sent every 300 ms if there was
 * no other activity on the MIDI port.
 *
 * @method sendActiveSensing
 * @chainable
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendActiveSensing(options?: { time?: number | string }): Output;

/**
 * Sends *Reset* real-time message. This tells the device connected to this port that is should
 * reset itself to a default state.
 *
 * @method sendReset
 * @chainable
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendReset(options?: { time?: number | string }): Output;

/**
 * Sends a MIDI **note off** message to the specified channel(s) for a single note or multiple
 * simultaneous notes (chord). You can delay the execution of the **note off** command by using
 * the `time` property of the `options` parameter (in milliseconds).
 *
 * @method stopNote
 * @chainable
 *
 * @param note {Number|Array<any>|string}  The note(s) you wish to stop. The notes can be specified in
 * one of three ways. The first way is by using the MIDI note number (an integer between `0` and
 * `127`). The second way is by using the note name followed by the octave (C3, G#4, F-1, Db7).
 * The octave range should be between -2 and 8. The lowest note is C-2 (MIDI note number 0) and
 * the highest note is G8 (MIDI note number 127). It is also possible to specify an array of note
 * numbers and/or names. The final way is to use the special value `all` to send an 'allnotesoff'
 * channel message.
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between `1` and `16`) or an
 * array of channel numbers. If the special value `all` is used (default), the message will be
 * sent to all 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {Boolean} [options.rawVelocity=false] Controls whether the release velocity is set using
 * an integer between `0` and `127` (`true`) or a decimal number between `0` and `1` (`false`,
 * default).
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @param {Number} [options.velocity=0.5] The velocity at which to release the note (between `0`
 * and `1`). If the `rawVelocity` option is `true`, the value should be specified as an integer
 * between `0` and `127`. An invalid velocity value will silently trigger the default of `0.5`.
 * Note that when the first parameter to `stopNote()` is `all`, the release velocity is silently
 * ignored.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function stopNote(
  note: number | Array<number | string> | string,
  channel?: number | Array<number | string> | string,
  options?: { rawVelocity?: Boolean; time?: number | string; velocity?: number }
): Output;

/**
 * Requests the playback of a single note or multiple notes on the specified channel(s). You can
 * delay the execution of the **note on** command by using the `time` property of the `options`
 * parameter (milliseconds).
 *
 * If no duration is specified in the `options`, the note will play until a matching **note off**
 * is sent. If a duration is specified, a **note off** will be automatically sent after said
 * duration.
 *
 * Note: As per the MIDI standard, a **note on** event with a velocity of `0` is considered to be
 * a **note off**.
 *
 * @method playNote
 * @chainable
 *
 * @param note {Number|string|Array}  The note(s) you wish to play. The notes can be specified in
 * one of two ways. The first way is by using the MIDI note number (an integer between 0 and 127).
 * The second way is by using the note name followed by the octave (C3, G#4, F-1, Db7). The octave
 * range should be between -2 and 8. The lowest note is C-2 (MIDI note number 0) and the highest
 * note is G8 (MIDI note number 127). It is also possible to specify an array of note numbers
 * and/or names.
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between `1` and `16`) or an
 * array of channel numbers. If the special value **all** is used (default), the message will be
 * sent to all 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {Number} [options.duration=undefined] The number of milliseconds (integer) to wait
 * before sending a matching **note off** event. If left undefined, only a **note on** message is
 * sent.
 *
 * @param {Boolean} [options.rawVelocity=false] Controls whether the attack and release velocities
 * are set using integers between `0` and `127` (`true`) or a decimal number between `0` and `1`
 * (`false`, default).
 *
 * @param {Number} [options.release=0.5] The velocity at which to release the note (between `0`
 * and `1`). If the `rawVelocity` option is `true`, the value should be specified as an integer
 * between `0` and `127`. An invalid velocity value will silently trigger the default of `0.5`.
 * This is only used with the **note off** event triggered when `options.duration` is set.
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @param {Number} [options.velocity=0.5] The velocity at which to play the note (between `0` and
 * `1`). If the `rawVelocity` option is `true`, the value should be specified as an integer
 * between `0` and `127`. An invalid velocity value will silently trigger the default of `0.5`.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function playNote(
  note: number | string | Array<number | string>,
  channel?: number | Array<number | string> | string,
  options?: { duration?: number; rawVelocity?: Boolean; release?: number; time?: number | string; velocity?: number }
): Output;

/**
 * Sends a MIDI `key aftertouch` message to the specified channel(s) at the scheduled time. This
 * is a key-specific aftertouch. For a channel-wide aftertouch message, use
 * {{#crossLink "WebMidi/sendChannelAftertouch:method"}}sendChannelAftertouch(){{/crossLink}}.
 *
 * @method sendKeyAftertouch
 * @chainable
 *
 * @param note {Number|string|Array}  The note for which you are sending an aftertouch value. The
 * notes can be specified in one of two ways. The first way is by using the MIDI note number (an
 * integer between 0 and 127). The second way is by using the note name followed by the octave
 * (C3, G#4, F-1, Db7). The octave range should be between -2 and 8. The lowest note is C-2 (MIDI
 * note number 0) and the highest note is G8 (MIDI note number 127). It is also possible to use
 * an array of note names and/or numbers.
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Number} [pressure=0.5] The pressure level to send (between 0 and 1).
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} The channel must be between 1 and 16.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendKeyAftertouch(
  note: number | string | Array<number | string>,
  channel?: number | Array<number | string> | string,
  pressure?: number,
  options?: { time?: number | string }
): Output;

/**
 * Sends a MIDI `control change` message to the specified channel(s) at the scheduled time. The
 * control change message to send can be specified numerically or by using one of the following
 * common names:
 *
 *  * `bankselectcoarse` (#0)
 *  * `modulationwheelcoarse` (#1)
 *  * `breathcontrollercoarse` (#2)
 *  * `footcontrollercoarse` (#4)
 *  * `portamentotimecoarse` (#5)
 *  * `dataentrycoarse` (#6)
 *  * `volumecoarse` (#7)
 *  * `balancecoarse` (#8)
 *  * `pancoarse` (#10)
 *  * `expressioncoarse` (#11)
 *  * `effectcontrol1coarse` (#12)
 *  * `effectcontrol2coarse` (#13)
 *  * `generalpurposeslider1` (#16)
 *  * `generalpurposeslider2` (#17)
 *  * `generalpurposeslider3` (#18)
 *  * `generalpurposeslider4` (#19)
 *  * `bankselectfine` (#32)
 *  * `modulationwheelfine` (#33)
 *  * `breathcontrollerfine` (#34)
 *  * `footcontrollerfine` (#36)
 *  * `portamentotimefine` (#37)
 *  * `dataentryfine` (#38)
 *  * `volumefine` (#39)
 *  * `balancefine` (#40)
 *  * `panfine` (#42)
 *  * `expressionfine` (#43)
 *  * `effectcontrol1fine` (#44)
 *  * `effectcontrol2fine` (#45)
 *  * `holdpedal` (#64)
 *  * `portamento` (#65)
 *  * `sustenutopedal` (#66)
 *  * `softpedal` (#67)
 *  * `legatopedal` (#68)
 *  * `hold2pedal` (#69)
 *  * `soundvariation` (#70)
 *  * `resonance` (#71)
 *  * `soundreleasetime` (#72)
 *  * `soundattacktime` (#73)
 *  * `brightness` (#74)
 *  * `soundcontrol6` (#75)
 *  * `soundcontrol7` (#76)
 *  * `soundcontrol8` (#77)
 *  * `soundcontrol9` (#78)
 *  * `soundcontrol10` (#79)
 *  * `generalpurposebutton1` (#80)
 *  * `generalpurposebutton2` (#81)
 *  * `generalpurposebutton3` (#82)
 *  * `generalpurposebutton4` (#83)
 *  * `reverblevel` (#91)
 *  * `tremololevel` (#92)
 *  * `choruslevel` (#93)
 *  * `celestelevel` (#94)
 *  * `phaserlevel` (#95)
 *  * `databuttonincrement` (#96)
 *  * `databuttondecrement` (#97)
 *  * `nonregisteredparametercoarse` (#98)
 *  * `nonregisteredparameterfine` (#99)
 *  * `registeredparametercoarse` (#100)
 *  * `registeredparameterfine` (#101)
 *
 * Note: as you can see above, not all control change message have a matching common name. This
 * does not mean you cannot use the others. It simply means you will need to use their number
 * instead of their name.
 *
 * To view a list of all available `control change` messages, please consult "Table 3 - Control
 * Change Messages" from the
 * [MIDI Messages](https://www.midi.org/specifications/item/table-3-control-change-messages-data-bytes-2)
 * specification.
 *
 * @method sendControlChange
 * @chainable
 *
 * @param controller {Number|string} The MIDI controller number (0-119) or name.
 *
 * @param [value=0] {Number} The value to send (0-127).
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} Controller numbers must be between 0 and 119.
 * @throws {RangeError} Value must be between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendControlChange(
  controller: number | string,
  value?: number,
  channel?: number | Array<number | string> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sets the specified MIDI registered parameter to the desired value. The value is defined with
 * up to two bytes of data that each can go from 0 to 127.
 *
 * >Unless you are very familiar with the MIDI standard you probably should favour one of the
 * >simpler to use functions such as: `setPitchbendRange()`, `setModulationRange()`,
 * >`setMasterTuning()`, etc.
 *
 * MIDI registered parameters extend the original list of control change messages. Currently,
 * there are only a limited number of them. Here are the original registered parameters with the
 * identifier that can be used as the first parameter of this function:
 *
 *  * Pitchbend Range (0x00, 0x00): `pitchbendrange`
 *  * Channel Fine Tuning (0x00, 0x01): `channelfinetuning`
 *  * Channel Coarse Tuning (0x00, 0x02): `channelcoarsetuning`
 *  * Tuning Program (0x00, 0x03): `tuningprogram`
 *  * Tuning Bank (0x00, 0x04): `tuningbank`
 *  * Modulation Range (0x00, 0x05): `modulationrange`
 *
 * Note that the **Tuning Program** and **Tuning Bank** parameters are part of the *MIDI Tuning
 * Standard*, which is not widely implemented.
 *
 * Another set of extra parameters have been later added for 3D sound controllers. They are:
 *
 *  * Azimuth Angle (0x3D, 0x00): `azimuthangle`
 *  * Elevation Angle (0x3D, 0x01): `elevationangle`
 *  * Gain (0x3D, 0x02): `gain`
 *  * Distance Ratio (0x3D, 0x03): `distanceratio`
 *  * Maximum Distance (0x3D, 0x04): `maximumdistance`
 *  * Maximum Distance Gain (0x3D, 0x05): `maximumdistancegain`
 *  * Reference Distance Ratio (0x3D, 0x06): `referencedistanceratio`
 *  * Pan Spread Angle (0x3D, 0x07): `panspreadangle`
 *  * Roll Angle (0x3D, 0x08): `rollangle`
 *
 * @method setRegisteredParameter
 * @chainable
 *
 * @param parameter {String|Array} A string identifying the parameter's name (see above) or a
 * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
 * parameter.
 *
 * @param [data=[]] {Number|Array} An single integer or an array of integers with a maximum length
 * of 2 specifying the desired data.
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @returns {Output} Returns the `Output` object so methods can be chained.
 */
export function setRegisteredParameter(
  parameter: string | number[2],
  data?: number | Array<number>,
  channel?: number | Array<number | string> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sets a non-registered parameter to the specified value. The NRPN is selected by passing in a
 * two-position array specifying the values of the two control bytes. The value is specified by
 * passing in an single integer (most cases) or an array of two integers.
 *
 * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way
 * they see fit. For example, according to the Roland GS specification, you can control the
 * **vibrato rate** using NRPN (1, 8). Therefore, to set the **vibrato rate** value to **123** you
 * would use:
 *
 *     WebMidi.outputs[0].setNonRegisteredParameter([1, 8], 123);
 *
 * Obviously, you should select a channel so the message is not sent to all channels. For
 * instance, to send to channel 1 of the first output port, you would use:
 *
 *     WebMidi.outputs[0].setNonRegisteredParameter([1, 8], 123, 1);
 *
 * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you
 * would use a 2-position array. For example, for its **ClockBPM** parameter (2, 63), Novation
 * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the
 * value to send was 10, you could use:
 *
 *     WebMidi.outputs[0].setNonRegisteredParameter([2, 63], [0, 10]);
 *
 * For further implementation details, refer to the manufacturer's documentation.
 *
 * @method setNonRegisteredParameter
 * @chainable
 *
 * @param parameter {Array} A two-position array specifying the two control bytes (0x63,
 * 0x62) that identify the non-registered parameter.
 *
 * @param [data=[]] {Number|Array} An integer or an array of integers with a length of 1 or 2
 * specifying the desired data.
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @returns {Output} Returns the `Output` object so methods can be chained.
 */
export function setNonRegisteredParameter(
  parameter: number[2],
  data?: number | Array<number>,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Increments the specified MIDI registered parameter by 1. For more specific MIDI usage
 * information, check out [RP-18](http://dev.midi.org/techspecs/rp18.php) regarding the usage of
 * increment and decrement controllers.
 *
 * >Unless you are very familiar with the MIDI standard you probably should favour one of the
 * >simpler to use functions such as: `setPitchbendRange()`, `setModulationRange()`,
 * >`setMasterTuning()`, etc.
 *
 * Here is the full list of parameter names that can be used with this function:
 *
 *  * Pitchbend Range (0x00, 0x00): `pitchbendrange`
 *  * Channel Fine Tuning (0x00, 0x01): `channelfinetuning`
 *  * Channel Coarse Tuning (0x00, 0x02): `channelcoarsetuning`
 *  * Tuning Program (0x00, 0x03): `tuningprogram`
 *  * Tuning Bank (0x00, 0x04): `tuningbank`
 *  * Modulation Range (0x00, 0x05): `modulationrange`
 *  * Azimuth Angle (0x3D, 0x00): `azimuthangle`
 *  * Elevation Angle (0x3D, 0x01): `elevationangle`
 *  * Gain (0x3D, 0x02): `gain`
 *  * Distance Ratio (0x3D, 0x03): `distanceratio`
 *  * Maximum Distance (0x3D, 0x04): `maximumdistance`
 *  * Maximum Distance Gain (0x3D, 0x05): `maximumdistancegain`
 *  * Reference Distance Ratio (0x3D, 0x06): `referencedistanceratio`
 *  * Pan Spread Angle (0x3D, 0x07): `panspreadangle`
 *  * Roll Angle (0x3D, 0x08): `rollangle`
 *
 * @method incrementRegisteredParameter
 * @chainable
 *
 * @param parameter {String|Array} A string identifying the parameter's name (see above) or a
 * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
 * parameter.
 *
 * @param [channel=all] {uint|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws Error The specified parameter is not available.
 *
 * @returns {Output} Returns the `Output` object so methods can be chained.
 */
export function incrementRegisteredParameter(
  parameter: string | number[2],
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Decrements the specified MIDI registered parameter by 1. For more specific MIDI usage
 * information, check out [RP-18](http://dev.midi.org/techspecs/rp18.php) regarding the usage of
 * increment and decrement controllers.
 *
 * >Unless you are very familiar with the MIDI standard you probably should favour one of the
 * >simpler to use functions such as: `setPitchbendRange()`, `setModulationRange()`,
 * >`setMasterTuning()`, etc.
 *
 * Here is the full list of parameter names that can be used with this function:
 *
 *  * Pitchbend Range (0x00, 0x00): `pitchbendrange`
 *  * Channel Fine Tuning (0x00, 0x01): `channelfinetuning`
 *  * Channel Coarse Tuning (0x00, 0x02): `channelcoarsetuning`
 *  * Tuning Program (0x00, 0x03): `tuningprogram`
 *  * Tuning Bank (0x00, 0x04): `tuningbank`
 *  * Modulation Range (0x00, 0x05): `modulationrange`
 *  * Azimuth Angle (0x3D, 0x00): `azimuthangle`
 *  * Elevation Angle (0x3D, 0x01): `elevationangle`
 *  * Gain (0x3D, 0x02): `gain`
 *  * Distance Ratio (0x3D, 0x03): `distanceratio`
 *  * Maximum Distance (0x3D, 0x04): `maximumdistance`
 *  * Maximum Distance Gain (0x3D, 0x05): `maximumdistancegain`
 *  * Reference Distance Ratio (0x3D, 0x06): `referencedistanceratio`
 *  * Pan Spread Angle (0x3D, 0x07): `panspreadangle`
 *  * Roll Angle (0x3D, 0x08): `rollangle`
 *
 * @method decrementRegisteredParameter
 * @chainable
 *
 * @param parameter {String|Array} A string identifying the parameter's name (see above) or a
 * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
 * parameter.
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws TypeError The specified parameter is not available.
 *
 * @returns {Output} Returns the `Output` object so methods can be chained.
 */
export function decrementRegisteredParameter(
  parameter: string | number[2],
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sends a pitch bend range message to the specified channel(s) at the scheduled time so that they
 * adjust the range used by their pitch bend lever. The range can be specified with the `semitones`
 * parameter, the `cents` parameter or by specifying both parameters at the same time.
 *
 * @method setPitchBendRange
 * @chainable
 *
 * @param [semitones=0] {Number} The desired adjustment value in semitones (integer between
 * 0-127). While nothing imposes that in the specification, it is very common for manufacturers to
 * limit the range to 2 octaves (-12 semitones to 12 semitones).
 *
 * @param [cents=0] {Number} The desired adjustment value in cents (integer between 0-127).
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} The semitones value must be between 0 and 127.
 * @throws {RangeError} The cents value must be between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function setPitchBendRange(
  semitones?: number,
  cents?: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sends a modulation depth range message to the specified channel(s) so that they adjust the
 * depth of their modulation wheel's range. The range can be specified with the `semitones`
 * parameter, the `cents` parameter or by specifying both parameters at the same time.
 *
 * @method setModulationRange
 * @chainable
 *
 * @param [semitones=0] {Number} The desired adjustment value in semitones (integer between
 * 0-127).
 *
 * @param [cents=0] {Number} The desired adjustment value in cents (0-127).
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} The semitones value must be between 0 and 127.
 * @throws {RangeError} The cents value must be between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function setModulationRange(
  semitones?: number,
  cents?: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sends a master tuning message to the specified channel(s). The value is decimal and must be
 * larger than -65 semitones and smaller than 64 semitones.
 *
 * >Because of the way the MIDI specification works, the decimal portion of the value will be
 * >encoded with a resolution of 14bit. The integer portion must be between -64 and 63
 * >inclusively. For those familiar with the MIDI protocol, this function actually generates
 * >**Master Coarse Tuning** and **Master Fine Tuning** RPN messages.
 *
 * @method setMasterTuning
 * @chainable
 *
 * @param [value=0.0] {Number} The desired decimal adjustment value in semitones (-65 < x < 64)
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller
 * than 64.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function setMasterTuning(
  value?: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the
 * *MIDI Tuning Standard*, which is not widely implemented.
 *
 * @method setTuningProgram
 * @chainable
 *
 * @param value {Number} The desired tuning program (0-127).
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} The program value must be between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function setTuningProgram(
  value: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the
 * *MIDI Tuning Standard*, which is not widely implemented.
 *
 * @method setTuningBank
 * @chainable
 *
 * @param value {Number} The desired tuning bank (0-127).
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} The bank value must be between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function setTuningBank(
  value: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sends a MIDI `channel mode` message to the specified channel(s). The channel mode message to send can be specified
 * numerically or by using one of the following common names:
 *
 *   * `allsoundoff` (#120)
 *   * `resetallcontrollers` (#121)
 *   * `localcontrol` (#122)
 *   * `allnotesoff` (#123)
 *   * `omnimodeoff` (#124)
 *   * `omnimodeon` (#125)
 *   * `monomodeon` (#126)
 *   * `polymodeon` (#127)
 *
 * It should be noted that, per the MIDI specification, only `localcontrol` and `monomodeon` may require a value
 * that's not zero. For that reason, the `value` parameter is optional and defaults to 0.
 *
 * @method sendChannelMode
 * @chainable
 *
 * @param command {Number|string} The numerical identifier of the channel mode message (integer between 120-127) or
 * its name as a string.
 * @param [value=0] {Number} The value to send (integer between 0-127).
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an array of channel
 * numbers. If the special value "all" is used, the message will be sent to all 16 channels.
 * @param {Object} [options={}]
 * @param {number|string} [options.time=undefined] This value can be one of two things. If the value is
 * a string starting with the + sign and followed by a number, the request will be delayed by the specified number
 * (in milliseconds). Otherwise, the value is considered a timestamp and the request will be scheduled at that
 * timestamp. The `number` value is relative to the navigation start of the document. To retrieve the
 * current time, you can use `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is
 * to be sent as soon as possible.
 *
 * @throws {TypeError} Invalid channel mode message name.
 * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.
 * @throws {RangeError} Value must be an integer between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 *
 */
export function sendChannelMode(
  command: number | string,
  value?: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sends a MIDI `program change` message to the specified channel(s) at the scheduled time.
 *
 * @method sendProgramChange
 * @chainable
 *
 * @param program {Number} The MIDI patch (program) number (0-127)
 *
 * @param [channel=all] {Number|Array<any>|string} The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} Program numbers must be between 0 and 127.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 *
 */
export function sendProgramChange(
  program: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sends a MIDI `channel aftertouch` message to the specified channel(s). For key-specific
 * aftertouch, you should instead use `sendKeyAftertouch()`.
 *
 * @method sendChannelAftertouch
 * @chainable
 *
 * @param [pressure=0.5] {Number} The pressure level (between 0 and 1). An invalid pressure value
 * will silently trigger the default behaviour.
 *
 * @param [channel=all] {Number|Array<any>|string}  The MIDI channel number (between 1 and 16) or
 * an array of channel numbers. If the special value "all" is used, the message will be sent to
 * all 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendChannelAftertouch(
  pressure?: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;

/**
 * Sends a MIDI `pitch bend` message to the specified channel(s) at the scheduled time.
 *
 * @method sendPitchBend
 * @chainable
 *
 * @param bend {Number} The intensity level of the bend (between -1 and 1). A value of zero means
 * no bend.
 *
 * @param [channel=all] {Number|Array<any>|string}  The MIDI channel number (between 1 and 16) or an
 * array of channel numbers. If the special value "all" is used, the message will be sent to all
 * 16 channels.
 *
 * @param {Object} [options={}]
 *
 * @param {number|string} [options.time=undefined] This value can be one of two
 * things. If the value is a string starting with the + sign and followed by a number, the request
 * will be delayed by the specified number (in milliseconds). Otherwise, the value is considered a
 * timestamp and the request will be scheduled at that timestamp. The `number` value
 * is relative to the navigation start of the document. To retrieve the current time, you can use
 * `WebMidi.time`. If `time` is not present or is set to a time in the past, the request is to be
 * sent as soon as possible.
 *
 * @throws {RangeError} Pitch bend value must be between -1 and 1.
 *
 * @return {Output} Returns the `Output` object so methods can be chained.
 */
export function sendPitchBend(
  bend: number,
  channel?: number | Array<number> | string,
  options?: { time?: number | string }
): Output;
